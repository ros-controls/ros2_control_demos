// Copyright (c) 2023, PAL Robotics
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef PASSTHROUGH_CONTROLLER__PASSTHROUGH_CONTROLLER_HPP_
#define PASSTHROUGH_CONTROLLER__PASSTHROUGH_CONTROLLER_HPP_

#include <controller_interface/chainable_controller_interface.hpp>
#include "controller_interface/helpers.hpp"
#include "realtime_tools/realtime_buffer.h"
#include "std_msgs/msg/float64_multi_array.hpp"
// auto-generated by generate_parameter_library
#include "passthrough_controller_parameters.hpp"

#include "passthrough_controller/visibility_control.h"

namespace passthrough_controller
{
using DataType = std_msgs::msg::Float64MultiArray;
class PassthroughController : public controller_interface::ChainableControllerInterface
{
public:
  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  PassthroughController() {}

  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  controller_interface::CallbackReturn on_init() override
  {
    try
    {
      param_listener_ = std::make_shared<ParamListener>(get_node());
      params_ = param_listener_->get_params();
    }
    catch (const std::exception & e)
    {
      fprintf(stderr, "Exception thrown during init stage with message: %s \n", e.what());
      return controller_interface::CallbackReturn::ERROR;
    }
    return controller_interface::CallbackReturn::SUCCESS;
  }

  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State &) override
  {
    params_ = param_listener_->get_params();
    command_interface_names_ = params_.interfaces;

    if (command_interface_names_.empty())
    {
      RCLCPP_ERROR(get_node()->get_logger(), "'interfaces' parameter list was empty");
      return controller_interface::CallbackReturn::ERROR;
    }

    joints_cmd_sub_ = this->get_node()->create_subscription<DataType>(
      "~/commands", rclcpp::SystemDefaultsQoS(),
      [this](const DataType::SharedPtr msg)
      {
        // check if message is correct size, if not ignore
        if (msg->data.size() == command_interface_names_.size())
        {
          rt_buffer_ptr_.writeFromNonRT(msg);
        }
        else
        {
          RCLCPP_ERROR(
            this->get_node()->get_logger(),
            "Invalid command received of %zu size, expected %zu size", msg->data.size(),
            command_interface_names_.size());
        }
      });

    // pre-reserve command interfaces
    command_interfaces_.reserve(command_interface_names_.size());

    RCLCPP_INFO(this->get_node()->get_logger(), "configure successful");

    // The names should be in the same order as for command interfaces for easier matching
    reference_interface_names_ = command_interface_names_;
    // for any case make reference interfaces size of command interfaces
    reference_interfaces_.resize(
      reference_interface_names_.size(), std::numeric_limits<double>::quiet_NaN());

    return controller_interface::CallbackReturn::SUCCESS;
  }

  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State &) override
  {
    //  check if we have all resources defined in the "points" parameter
    //  also verify that we *only* have the resources defined in the "points" parameter
    // ATTENTION(destogl): Shouldn't we use ordered interface all the time?
    std::vector<std::reference_wrapper<hardware_interface::LoanedCommandInterface>>
      ordered_interfaces;
    if (
      !controller_interface::get_ordered_interfaces(
        command_interfaces_, command_interface_names_, std::string(""), ordered_interfaces) ||
      command_interface_names_.size() != ordered_interfaces.size())
    {
      RCLCPP_ERROR(
        this->get_node()->get_logger(), "Expected %zu command interfaces, got %zu",
        command_interface_names_.size(), ordered_interfaces.size());
      return controller_interface::CallbackReturn::ERROR;
    }

    // reset command buffer if a command came through callback when controller was inactive
    rt_buffer_ptr_ = realtime_tools::RealtimeBuffer<std::shared_ptr<DataType>>(nullptr);

    RCLCPP_INFO(this->get_node()->get_logger(), "activate successful");

    std::fill(
      reference_interfaces_.begin(), reference_interfaces_.end(),
      std::numeric_limits<double>::quiet_NaN());

    return controller_interface::CallbackReturn::SUCCESS;
  }

  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  controller_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State &) override
  {
    // reset command buffer
    rt_buffer_ptr_ = realtime_tools::RealtimeBuffer<std::shared_ptr<DataType>>(nullptr);
    return controller_interface::CallbackReturn::SUCCESS;
  }

  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  controller_interface::InterfaceConfiguration command_interface_configuration() const override
  {
    controller_interface::InterfaceConfiguration command_interfaces_config;
    command_interfaces_config.type = controller_interface::interface_configuration_type::INDIVIDUAL;
    command_interfaces_config.names = command_interface_names_;

    return command_interfaces_config;
  }

  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  controller_interface::InterfaceConfiguration state_interface_configuration() const override
  {
    return controller_interface::InterfaceConfiguration{
      controller_interface::interface_configuration_type::NONE};
  }

  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  controller_interface::return_type update_reference_from_subscribers(
    const rclcpp::Time & /* time */, const rclcpp::Duration & /* period */) override
  {
    auto joint_commands = rt_buffer_ptr_.readFromRT();
    // message is valid
    if (!(!joint_commands || !(*joint_commands)))
    {
      if (reference_interfaces_.size() != (*joint_commands)->data.size())
      {
        RCLCPP_ERROR_THROTTLE(
          get_node()->get_logger(), *(get_node()->get_clock()), 1000,
          "command size (%zu) does not match number of reference interfaces (%zu)",
          (*joint_commands)->data.size(), reference_interfaces_.size());
        return controller_interface::return_type::ERROR;
      }
      reference_interfaces_ = (*joint_commands)->data;
    }

    return controller_interface::return_type::OK;
  }

protected:
  std::vector<hardware_interface::CommandInterface> on_export_reference_interfaces() override
  {
    std::vector<hardware_interface::CommandInterface> reference_interfaces;

    for (size_t i = 0; i < reference_interface_names_.size(); ++i)
    {
      reference_interfaces.push_back(hardware_interface::CommandInterface(
        get_node()->get_name(), reference_interface_names_[i], &reference_interfaces_[i]));
    }

    return reference_interfaces;
  }

  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  bool on_set_chained_mode(bool /* chained_mode */) override { return true; }

  PASSTHROUGH_CONTROLLER__VISIBILITY_PUBLIC
  controller_interface::return_type update_and_write_commands(
    const rclcpp::Time & /* time */, const rclcpp::Duration & /* period */) override
  {
    for (size_t i = 0; i < command_interfaces_.size(); ++i)
    {
      if (!std::isnan(reference_interfaces_[i]))
      {
        command_interfaces_[i].set_value(reference_interfaces_[i]);
      }
    }

    return controller_interface::return_type::OK;
  }

  std::shared_ptr<ParamListener> param_listener_;
  Params params_;

  realtime_tools::RealtimeBuffer<std::shared_ptr<DataType>> rt_buffer_ptr_;
  rclcpp::Subscription<DataType>::SharedPtr joints_cmd_sub_;

  std::vector<std::string> reference_interface_names_;

  std::vector<std::string> command_interface_names_;
};

}  // namespace passthrough_controller

#endif  // PASSTHROUGH_CONTROLLER__PASSTHROUGH_CONTROLLER_HPP_
